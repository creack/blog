<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Guillaume&#39;s Thoughts </title>
    <link>https://blog.charmes.net/tags/golang/</link>
    <language>en-us</language>
    <author></author>
    <rights>(C) 2014</rights>
    <updated>2014-11-09 19:01:11 -0500 -0500</updated>

    
      
        <item>
          <title>Release Go code (and others) via Docker using Makefile</title>
          <link>https://blog.charmes.net/post/release-go-code/</link>
          <pubDate>Sun, 09 Nov 2014 19:01:11 -0500</pubDate>
          <author></author>
          <guid>https://blog.charmes.net/post/release-go-code/</guid>
          <description>

&lt;p&gt;&lt;center&gt;
&lt;img border=&#34;0&#34; src=&#34;http://ddf912383141a8d7bbe4-e053e711fc85de3290f121ef0f0e3a1f.r87.cf1.rackcdn.com/docker-whale.png&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;In this article, I&amp;rsquo;ll demonstrate how to leverage Makefile in order to release lightweight Docker image for production.&lt;/p&gt;

&lt;h2 id=&#34;sample-application-code&#34;&gt;Sample Application code&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main

func main() {
        println(&amp;quot;hello world&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, do not forget to vendor your dependencies: &lt;code&gt;godep save&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In order to create a release image, we first need to build the binary. We will have 2 Dockerfiles.&lt;/p&gt;

&lt;h2 id=&#34;main-dockerfile&#34;&gt;Main Dockerfile&lt;/h2&gt;

&lt;p&gt;The main Dockerfile is the &amp;ldquo;classic&amp;rdquo; one. For our example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;# Using google/golang as base image
FROM            google/golang:stable
# Install Godep for vendoring
RUN             go get github.com/tools/godep
# Recompile the standard library without CGO
RUN				CGO_ENABLED=0 go install -a std
# Declare the maintainer
MAINTAINER      Guillaume J. Charmes &amp;lt;guillaume@charmes.net&amp;gt;

# For convenience, set an env variable with the path of the code
ENV             APP_DIR         $GOPATH/src/example

# Set the entrypoint as the binary, so `docker run &amp;lt;image&amp;gt;` will behave as the binary
ENTRYPOINT      [&amp;quot;/example&amp;quot;]
# Add the sources to the APP_DIR
ADD             .       $APP_DIR
# Compile the binary and statically link
RUN             cd $APP_DIR &amp;amp;&amp;amp; CGO_ENABLED=0 godep go build -o /example -ldflags &#39;-d -w -s&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the &lt;code&gt;godep&lt;/code&gt;  install and the CGO disabled std rebuild are done before the maintainer, this allows to keep the cache for this part when the maintainer changes.
In a future article, I&amp;rsquo;ll talk more in depth about static linking in Go (the &lt;code&gt;-ldflags&lt;/code&gt; and &lt;code&gt;go install std&lt;/code&gt; thingy)&lt;/p&gt;

&lt;h2 id=&#34;release-dockerfile&#34;&gt;Release Dockerfile&lt;/h2&gt;

&lt;p&gt;In order to release, we need a second Dockerfile. As Docker builds directories, we need to create a subdirectory &lt;code&gt;release&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The release Makefile is very straight forward and look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;# Use &amp;quot;scratch&amp;quot; as base: it is an empty image.
FROM            scratch
# Set the entrypoint as the binary, so `docker run &amp;lt;image&amp;gt;` will behave as the binary
ENTRYPOINT      [&amp;quot;/example&amp;quot;]
# Add the binary. As it is statically linked, no need to add libc or anything else.
ADD             example /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we need a Makefile to automate the process&lt;/p&gt;

&lt;h2 id=&#34;makefile&#34;&gt;Makefile&lt;/h2&gt;

&lt;p&gt;The Makefile allow for easy dependency scripting.&lt;/p&gt;

&lt;p&gt;The goal is to push a &amp;ldquo;release&amp;rdquo; image. In order to do this, we need to have that image built.
In order to build this image, we need the binary, In order to get the binary, we need to build.
In order to build, we need the source. For convenience, we monitor &lt;code&gt;.&lt;/code&gt; instead of each individual go files.&lt;/p&gt;

&lt;p&gt;The default rule is &lt;code&gt;all&lt;/code&gt; which triggers &lt;code&gt;build&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;build&lt;/code&gt; depends on &lt;code&gt;.build&lt;/code&gt; which is a file. If it exists then move on to the next dependency, otherwise, execute the rule. &lt;code&gt;.build&lt;/code&gt; depend on &lt;code&gt;.&lt;/code&gt;. This means that if anything changes in the current directoty, the cache gets invalidated and the rule will be executed.
In order to build, we call &lt;code&gt;docker build&lt;/code&gt; and create the &lt;code&gt;.build&lt;/code&gt; file.
The result is a full blown image roughly 600MB. &lt;code&gt;release&lt;/code&gt; will help with this.
The first step is to extract the binary and &lt;code&gt;/etc/ssl&lt;/code&gt;. The &lt;code&gt;/etc/ssl&lt;/code&gt; is mandatory only if you plan on using SSL (otherwise, Go will complain it does not find the certificates). Once extracted in a tarball, we build the release Dockerfile.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;NAME            = example
DOCKER_IMAGE    = 127.0.0.1:5000/$(NAME)

all             : build

.build          : .
                docker build -t $(NAME) .
                docker inspect -f &#39;{{.Id}}&#39; $(NAME) &amp;gt; .build

build           : .build

release/$(NAME) : build
                docker run --rm --entrypoint /bin/sh $(NAME) -c &#39;tar cf - /$(NAME) /etc/ssl&#39; &amp;gt; $@ || (rm -f $@; false)
                docker build --rm -t $(DOCKER_IMAGE) release

release         : release/$(NAME)

push            : release
                docker push $(DOCKER_IMAGE)

clean           :
                $(RM) .build release/$(NAME)

.PHONY          : push release build all clean
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;directory-tree&#34;&gt;Directory tree&lt;/h2&gt;

&lt;p&gt;In the end, the directory tree should look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;$&amp;gt; tree
.
├── Dockerfile
├── Godeps
│   ├── Godeps.json
│   ├── Readme
│   └── _workspace
├── Makefile
├── main.go
└── release
    └── Dockerfile

3 directories, 6 files
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;As we saw, the release process is a dependency cascade, which make the Makefile very useful.
The advantages of using something like this is easily shown by &lt;code&gt;docker images&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;Original image&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;$&amp;gt; docker images example
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
example             latest              e68fcc5482a8        10 seconds ago          605.3 MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Release image&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;$&amp;gt; docker images 127.0.0.1:5000/example
REPOSITORY               TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
127.0.0.1:5000/example   latest              6e9e455bf60d        4 seconds ago          617.6 kB
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    

  </channel>
</rss>
